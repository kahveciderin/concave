import type { ConcaveSchema, TypeInfo, FieldSchemaInfo, ResourceSchemaInfo } from "../openapi/schema";

export interface TypegenOptions {
  serverUrl: string;
  output?: "typescript" | "dart" | "json";
  namespace?: string;
  includeClient?: boolean;
}

export interface TypegenResult {
  code: string;
  schema: ConcaveSchema;
  generatedAt: string;
}

export const fetchSchema = async (serverUrl: string): Promise<ConcaveSchema> => {
  const url = serverUrl.replace(/\/$/, "") + "/__concave/schema";
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to fetch schema: ${response.status} ${response.statusText}`);
  }
  return response.json();
};

export const generateTypes = async (options: TypegenOptions): Promise<TypegenResult> => {
  const schema = await fetchSchema(options.serverUrl);
  const output = options.output ?? "typescript";

  let code: string;
  switch (output) {
    case "typescript":
      code = generateTypeScript(schema, options);
      break;
    case "dart":
      code = generateDart(schema, options);
      break;
    case "json":
      code = JSON.stringify(schema, null, 2);
      break;
    default:
      throw new Error(`Unsupported output format: ${output}`);
  }

  return {
    code,
    schema,
    generatedAt: new Date().toISOString(),
  };
};

const typeInfoToTS = (typeInfo: TypeInfo): string => {
  if (typeInfo.kind === "primitive") {
    switch (typeInfo.primitive) {
      case "integer":
      case "number":
        return "number";
      case "boolean":
        return "boolean";
      case "datetime":
      case "date":
      case "time":
      case "uuid":
      case "string":
        return "string";
      case "json":
        return "Record<string, unknown>";
      default:
        return "string";
    }
  }
  if (typeInfo.kind === "array") {
    const itemType = typeInfo.items ? typeInfoToTS(typeInfo.items) : "unknown";
    return `${itemType}[]`;
  }
  if (typeInfo.kind === "object") {
    return "Record<string, unknown>";
  }
  if (typeInfo.kind === "enum" && typeInfo.enumValues) {
    return typeInfo.enumValues.map(v => `"${v}"`).join(" | ");
  }
  if (typeInfo.kind === "union" && typeInfo.unionTypes) {
    return typeInfo.unionTypes.map(typeInfoToTS).join(" | ");
  }
  return "unknown";
};

const typeInfoToDart = (typeInfo: TypeInfo): string => {
  if (typeInfo.kind === "primitive") {
    switch (typeInfo.primitive) {
      case "integer":
        return "int";
      case "number":
        return "double";
      case "boolean":
        return "bool";
      case "datetime":
        return "DateTime";
      case "date":
      case "time":
      case "uuid":
      case "string":
        return "String";
      case "json":
        return "Map<String, dynamic>";
      default:
        return "String";
    }
  }
  if (typeInfo.kind === "array") {
    const itemType = typeInfo.items ? typeInfoToDart(typeInfo.items) : "dynamic";
    return `List<${itemType}>`;
  }
  if (typeInfo.kind === "object") {
    return "Map<String, dynamic>";
  }
  if (typeInfo.kind === "enum" && typeInfo.enumValues) {
    return "String";
  }
  if (typeInfo.kind === "union" && typeInfo.unionTypes) {
    return "dynamic";
  }
  return "dynamic";
};

const generateTypeScript = (schema: ConcaveSchema, options: TypegenOptions): string => {
  const ns = options.namespace;
  let output = `// Generated by Concave Typegen v${schema.version}\n`;
  output += `// Server: ${options.serverUrl}\n`;
  output += `// Generated at: ${schema.timestamp}\n\n`;

  if (ns) {
    output += `export namespace ${ns} {\n`;
  }

  const indent = ns ? "  " : "";

  for (const resource of schema.resources) {
    output += `${indent}export interface ${resource.name} {\n`;
    for (const field of resource.fields) {
      const tsType = typeInfoToTS(field.type);
      const nullSuffix = field.nullable ? " | null" : "";
      output += `${indent}  ${field.name}: ${tsType}${nullSuffix};\n`;
    }
    output += `${indent}}\n\n`;

    const autoFields = resource.fields
      .filter(f => f.primaryKey || f.autoIncrement)
      .map(f => `"${f.name}"`)
      .join(" | ");
    const omitType = autoFields ? `Omit<${resource.name}, ${autoFields}>` : resource.name;
    output += `${indent}export type ${resource.name}Input = ${omitType};\n`;
    output += `${indent}export type ${resource.name}Update = Partial<${resource.name}Input>;\n\n`;
  }

  if (options.includeClient !== false) {
    output += generateTSClientTypes(schema, indent);
  }

  if (ns) {
    output += `}\n`;
  }

  return output;
};

const generateTSClientTypes = (schema: ConcaveSchema, indent: string): string => {
  let output = "";

  output += `${indent}export interface ConcaveClient {\n`;
  for (const resource of schema.resources) {
    const lowerName = resource.name.charAt(0).toLowerCase() + resource.name.slice(1);
    output += `${indent}  ${lowerName}: ResourceClient<${resource.name}>;\n`;
  }
  output += `${indent}}\n\n`;

  output += `${indent}export interface ResourceClient<T> {\n`;
  output += `${indent}  list(options?: ListOptions): Promise<PaginatedResponse<T>>;\n`;
  output += `${indent}  get(id: string | number, options?: GetOptions): Promise<T>;\n`;
  output += `${indent}  count(filter?: string): Promise<number>;\n`;
  output += `${indent}  aggregate(options: AggregateOptions): Promise<AggregationResponse>;\n`;
  output += `${indent}  create(data: Partial<T>, options?: CreateOptions): Promise<T>;\n`;
  output += `${indent}  update(id: string | number, data: Partial<T>, options?: UpdateOptions): Promise<T>;\n`;
  output += `${indent}  delete(id: string | number): Promise<void>;\n`;
  output += `${indent}  subscribe(options?: SubscribeOptions, callbacks?: SubscriptionCallbacks<T>): Subscription<T>;\n`;
  output += `${indent}  rpc<TInput, TOutput>(name: string, input: TInput): Promise<TOutput>;\n`;
  output += `${indent}}\n\n`;

  output += `${indent}export interface ListOptions {\n`;
  output += `${indent}  filter?: string;\n`;
  output += `${indent}  select?: string[];\n`;
  output += `${indent}  cursor?: string;\n`;
  output += `${indent}  limit?: number;\n`;
  output += `${indent}  orderBy?: string;\n`;
  output += `${indent}  totalCount?: boolean;\n`;
  output += `${indent}}\n\n`;

  output += `${indent}export interface GetOptions {\n`;
  output += `${indent}  select?: string[];\n`;
  output += `${indent}}\n\n`;

  output += `${indent}export interface CreateOptions {\n`;
  output += `${indent}  idempotencyKey?: string;\n`;
  output += `${indent}}\n\n`;

  output += `${indent}export interface UpdateOptions {\n`;
  output += `${indent}  ifMatch?: string;\n`;
  output += `${indent}}\n\n`;

  output += `${indent}export interface SubscribeOptions {\n`;
  output += `${indent}  filter?: string;\n`;
  output += `${indent}  resumeFrom?: number;\n`;
  output += `${indent}}\n\n`;

  output += `${indent}export interface AggregateOptions {\n`;
  output += `${indent}  filter?: string;\n`;
  output += `${indent}  groupBy?: string[];\n`;
  output += `${indent}  count?: boolean;\n`;
  output += `${indent}  sum?: string[];\n`;
  output += `${indent}  avg?: string[];\n`;
  output += `${indent}  min?: string[];\n`;
  output += `${indent}  max?: string[];\n`;
  output += `${indent}}\n\n`;

  output += `${indent}export interface PaginatedResponse<T> {\n`;
  output += `${indent}  items: T[];\n`;
  output += `${indent}  nextCursor: string | null;\n`;
  output += `${indent}  hasMore: boolean;\n`;
  output += `${indent}  totalCount?: number;\n`;
  output += `${indent}}\n\n`;

  output += `${indent}export interface AggregationResponse {\n`;
  output += `${indent}  groups: Array<{\n`;
  output += `${indent}    key: Record<string, unknown> | null;\n`;
  output += `${indent}    count?: number;\n`;
  output += `${indent}    sum?: Record<string, number>;\n`;
  output += `${indent}    avg?: Record<string, number>;\n`;
  output += `${indent}    min?: Record<string, number | string>;\n`;
  output += `${indent}    max?: Record<string, number | string>;\n`;
  output += `${indent}  }>;\n`;
  output += `${indent}}\n\n`;

  output += `${indent}export interface Subscription<T> {\n`;
  output += `${indent}  readonly items: T[];\n`;
  output += `${indent}  unsubscribe(): void;\n`;
  output += `${indent}  reconnect(): void;\n`;
  output += `${indent}}\n\n`;

  output += `${indent}export interface SubscriptionCallbacks<T> {\n`;
  output += `${indent}  onAdded?: (item: T) => void;\n`;
  output += `${indent}  onChanged?: (item: T, previousId?: string) => void;\n`;
  output += `${indent}  onRemoved?: (id: string) => void;\n`;
  output += `${indent}  onInvalidate?: (reason?: string) => void;\n`;
  output += `${indent}  onError?: (error: Error) => void;\n`;
  output += `${indent}}\n`;

  return output;
};

const generateDart = (schema: ConcaveSchema, options: TypegenOptions): string => {
  let output = `// Generated by Concave Typegen v${schema.version}\n`;
  output += `// Server: ${options.serverUrl}\n`;
  output += `// Generated at: ${schema.timestamp}\n\n`;
  output += `import 'dart:convert';\n\n`;

  for (const resource of schema.resources) {
    output += generateDartClass(resource);
  }

  if (options.includeClient !== false) {
    output += generateDartClientTypes(schema);
  }

  return output;
};

const generateDartClass = (resource: ResourceSchemaInfo): string => {
  let output = `class ${resource.name} {\n`;

  for (const field of resource.fields) {
    const dartType = typeInfoToDart(field.type);
    const nullSuffix = field.nullable ? "?" : "";
    output += `  final ${dartType}${nullSuffix} ${field.name};\n`;
  }
  output += `\n`;

  output += `  ${resource.name}({\n`;
  for (const field of resource.fields) {
    const required = !field.nullable && !field.primaryKey && !field.autoIncrement;
    output += `    ${required ? "required " : ""}this.${field.name},\n`;
  }
  output += `  });\n\n`;

  output += `  factory ${resource.name}.fromJson(Map<String, dynamic> json) {\n`;
  output += `    return ${resource.name}(\n`;
  for (const field of resource.fields) {
    const dartType = typeInfoToDart(field.type);
    let converter = `json['${field.name}']`;
    if (dartType === "DateTime") {
      converter = field.nullable
        ? `json['${field.name}'] != null ? DateTime.parse(json['${field.name}']) : null`
        : `DateTime.parse(json['${field.name}'])`;
    } else if (dartType === "int" && field.nullable) {
      converter = `json['${field.name}'] as int?`;
    } else if (dartType === "double" && field.nullable) {
      converter = `(json['${field.name}'] as num?)?.toDouble()`;
    } else if (dartType === "double") {
      converter = `(json['${field.name}'] as num).toDouble()`;
    }
    output += `      ${field.name}: ${converter},\n`;
  }
  output += `    );\n`;
  output += `  }\n\n`;

  output += `  Map<String, dynamic> toJson() {\n`;
  output += `    return {\n`;
  for (const field of resource.fields) {
    const dartType = typeInfoToDart(field.type);
    let value = field.name;
    if (dartType === "DateTime") {
      value = field.nullable ? `${field.name}?.toIso8601String()` : `${field.name}.toIso8601String()`;
    }
    output += `      '${field.name}': ${value},\n`;
  }
  output += `    };\n`;
  output += `  }\n`;

  output += `}\n\n`;

  const inputFields = resource.fields.filter(f => !f.primaryKey && !f.autoIncrement);
  output += `class ${resource.name}Input {\n`;
  for (const field of inputFields) {
    const dartType = typeInfoToDart(field.type);
    const nullSuffix = field.nullable ? "?" : "";
    output += `  final ${dartType}${nullSuffix} ${field.name};\n`;
  }
  output += `\n`;

  output += `  ${resource.name}Input({\n`;
  for (const field of inputFields) {
    const required = !field.nullable;
    output += `    ${required ? "required " : ""}this.${field.name},\n`;
  }
  output += `  });\n\n`;

  output += `  Map<String, dynamic> toJson() {\n`;
  output += `    return {\n`;
  for (const field of inputFields) {
    const dartType = typeInfoToDart(field.type);
    let value = field.name;
    if (dartType === "DateTime") {
      value = field.nullable ? `${field.name}?.toIso8601String()` : `${field.name}.toIso8601String()`;
    }
    output += `      '${field.name}': ${value},\n`;
  }
  output += `    };\n`;
  output += `  }\n`;
  output += `}\n\n`;

  return output;
};

const generateDartClientTypes = (schema: ConcaveSchema): string => {
  let output = `// Client types\n\n`;

  output += `class ListOptions {\n`;
  output += `  final String? filter;\n`;
  output += `  final List<String>? select;\n`;
  output += `  final String? cursor;\n`;
  output += `  final int? limit;\n`;
  output += `  final String? orderBy;\n`;
  output += `  final bool? totalCount;\n\n`;
  output += `  ListOptions({this.filter, this.select, this.cursor, this.limit, this.orderBy, this.totalCount});\n`;
  output += `}\n\n`;

  output += `class PaginatedResponse<T> {\n`;
  output += `  final List<T> items;\n`;
  output += `  final String? nextCursor;\n`;
  output += `  final bool hasMore;\n`;
  output += `  final int? totalCount;\n\n`;
  output += `  PaginatedResponse({required this.items, this.nextCursor, required this.hasMore, this.totalCount});\n`;
  output += `}\n\n`;

  output += `class SubscribeOptions {\n`;
  output += `  final String? filter;\n`;
  output += `  final int? resumeFrom;\n\n`;
  output += `  SubscribeOptions({this.filter, this.resumeFrom});\n`;
  output += `}\n\n`;

  output += `class AggregateOptions {\n`;
  output += `  final String? filter;\n`;
  output += `  final List<String>? groupBy;\n`;
  output += `  final bool? count;\n`;
  output += `  final List<String>? sum;\n`;
  output += `  final List<String>? avg;\n`;
  output += `  final List<String>? min;\n`;
  output += `  final List<String>? max;\n\n`;
  output += `  AggregateOptions({this.filter, this.groupBy, this.count, this.sum, this.avg, this.min, this.max});\n`;
  output += `}\n\n`;

  return output;
};

export const createTypegenCLI = async (args: string[]): Promise<void> => {
  const serverUrl = args[0];
  const output = (args[1] as TypegenOptions["output"]) ?? "typescript";

  if (!serverUrl) {
    console.error("Usage: concave-typegen <server-url> [typescript|dart|json]");
    process.exit(1);
  }

  try {
    const result = await generateTypes({ serverUrl, output });
    console.log(result.code);
  } catch (error) {
    console.error("Error generating types:", error);
    process.exit(1);
  }
};
